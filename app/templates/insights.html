{% extends "base.html" %}

{% block title %}Insights - Windborne Constellation Tracker{% endblock %}

{% block extra_css %}
<style>
    .insight-card {
        transition: transform 0.3s ease;
        height: 100%;
    }
    
    .insight-card:hover {
        transform: translateY(-5px);
    }
    
    .chart-container {
        height: 300px;
        position: relative;
    }
    
    .notes-section {
        background-color: #f8f9fa;
        border-left: 4px solid #0d6efd;
        padding: 15px;
        margin-bottom: 20px;
    }
    
    #weather-map {
        height: 400px;
    }
    
    .openweather-api-section {
        background-color: rgba(255, 255, 255, 0.9);
        padding: 15px;
        border-radius: 5px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
    }
    
    .weather-overlay-options {
        margin-top: 10px;
    }
    
    #api-key-input {
        max-width: 350px;
    }
</style>
{% endblock %}

{% block content %}
<div class="row mb-3">
    <div class="col-12">
        <div class="d-flex justify-content-between align-items-center">
            <h1>Operational Insights</h1>
            <div>
                <button id="refresh-insights-btn" class="btn btn-outline-primary">
                    <i class="bi bi-arrow-clockwise"></i> Refresh
                </button>
                <small id="last-updated" class="text-muted ms-2">Last updated: Loading...</small>
            </div>
        </div>
    </div>
</div>

<div class="row mb-4">
    <div class="col-12">
        <div class="notes-section">
            <h5>Project Notes</h5>
            <p>
                This project combines Windborne's balloon constellation data with weather information 
                to provide operational insights for fleet management. By correlating balloon 
                positions with real-time weather data, we can identify patterns that affect 
                balloon performance, predict potential flight risks, and optimize future deployments.
            </p>
            <p>
                <strong>Why this approach?</strong> Understanding the interaction between atmospheric 
                conditions and balloon behavior helps Windborne optimize flight paths, improve 
                balloon longevity, and enhance the quality of collected data. This interface 
                provides both strategic overview and detailed balloon-specific insights.
            </p>
        </div>
    </div>
</div>

<div class="row mb-4">
    <div class="col-12">
        <div class="card">
            <div class="card-header">
                <h5 class="card-title mb-0">Weather and Balloon Integration</h5>
            </div>
            <div class="card-body">
                <div class="openweather-api-section">
                    <h6>OpenWeather API Integration</h6>
                    <p>
                        Visualize balloon positions alongside real-time weather data. 
                        This feature requires an OpenWeather API key to fetch current weather conditions.
                    </p>
                    <div class="row align-items-center">
                        <div class="col-md-6">
                            <div class="input-group mb-3" id="api-key-input">
                                <input type="text" class="form-control" id="weather-api-key" placeholder="Enter OpenWeather API Key">
                                <button class="btn btn-outline-primary" type="button" id="apply-api-key">Apply</button>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="weather-overlay-options">
                                <div class="form-check form-check-inline">
                                    <input class="form-check-input" type="radio" name="weatherOverlay" id="clouds-overlay" value="clouds" checked>
                                    <label class="form-check-label" for="clouds-overlay">Clouds</label>
                                </div>
                                <div class="form-check form-check-inline">
                                    <input class="form-check-input" type="radio" name="weatherOverlay" id="temp-overlay" value="temp">
                                    <label class="form-check-label" for="temp-overlay">Temperature</label>
                                </div>
                                <div class="form-check form-check-inline">
                                    <input class="form-check-input" type="radio" name="weatherOverlay" id="wind-overlay" value="wind">
                                    <label class="form-check-label" for="wind-overlay">Wind</label>
                                </div>
                                <div class="form-check form-check-inline">
                                    <input class="form-check-input" type="radio" name="weatherOverlay" id="precipitation-overlay" value="precipitation">
                                    <label class="form-check-label" for="precipitation-overlay">Precipitation</label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="weather-map"></div>
            </div>
        </div>
    </div>
</div>

<div class="row mb-4">
    <div class="col-md-6">
        <div class="card insight-card">
            <div class="card-header">
                <h5 class="card-title mb-0">Wind Impact on Balloon Speed</h5>
            </div>
            <div class="card-body">
                <div class="chart-container">
                    <canvas id="wind-impact-chart"></canvas>
                </div>
                <div class="mt-3">
                    <p id="wind-impact-insight">Loading analysis...</p>
                </div>
            </div>
        </div>
    </div>
    <div class="col-md-6">
        <div class="card insight-card">
            <div class="card-header">
                <h5 class="card-title mb-0">Altitude vs. Weather Conditions</h5>
            </div>
            <div class="card-body">
                <div class="chart-container">
                    <canvas id="altitude-weather-chart"></canvas>
                </div>
                <div class="mt-3">
                    <p id="altitude-weather-insight">Loading analysis...</p>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="row">
    <div class="col-md-4">
        <div class="card insight-card">
            <div class="card-header">
                <h5 class="card-title mb-0">Balloon Performance Index</h5>
            </div>
            <div class="card-body">
                <div class="chart-container">
                    <canvas id="performance-chart"></canvas>
                </div>
                <div class="mt-3">
                    <p id="performance-insight">Loading analysis...</p>
                </div>
            </div>
        </div>
    </div>
    <div class="col-md-4">
        <div class="card insight-card">
            <div class="card-header">
                <h5 class="card-title mb-0">Deployment Recommendations</h5>
            </div>
            <div class="card-body">
                <div id="deployment-recommendations">
                    <div class="d-flex align-items-center mb-3">
                        <div class="spinner-border text-primary me-2" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <span>Generating recommendations...</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="col-md-4">
        <div class="card insight-card">
            <div class="card-header">
                <h5 class="card-title mb-0">Anomaly Detection</h5>
            </div>
            <div class="card-body">
                <div id="anomaly-detection">
                    <div class="d-flex align-items-center mb-3">
                        <div class="spinner-border text-primary me-2" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <span>Analyzing balloon patterns...</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    // Global variables
    let balloonData = null;
    let weatherApiKey = localStorage.getItem('weatherApiKey') || '';
    let selectedWeatherOverlay = 'clouds';
    let weatherMap = null;
    let balloonMarkersGroup = null;
    let weatherLayer = null;
    
    // Chart instances
    let windImpactChart = null;
    let altitudeWeatherChart = null;
    let performanceChart = null;
    
    // Function to update insights with latest data
    async function updateInsights() {
        try {
            // Fetch balloon data from our API
            const response = await fetch('/api/balloons');
            balloonData = await response.json();
            
            if (!balloonData) {
                console.error('No data received from API');
                return;
            }
            
            // Update last updated time
            document.getElementById('last-updated').textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
            
            // Initialize or update weather map
            initializeWeatherMap();
            
            // Update charts and insights
            updateWindImpactChart();
            updateAltitudeWeatherChart();
            updatePerformanceChart();
            updateDeploymentRecommendations();
            updateAnomalyDetection();
            
        } catch (error) {
            console.error('Error updating insights:', error);
        }
    }
    
    // Function to initialize weather map
    function initializeWeatherMap() {
        if (!weatherMap) {
            // Initialize map
            weatherMap = L.map('weather-map').setView([20, 0], 2);
            
            // Add the base map layer
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(weatherMap);
            
            // Create balloon markers layer group
            balloonMarkersGroup = L.layerGroup().addTo(weatherMap);
        }
        
        // Update balloon markers
        updateBalloonMarkersOnMap();
        
        // Update weather layer if API key is available
        if (weatherApiKey) {
            updateWeatherLayer();
        }
    }
    
    // Function to update balloon markers on the map
    function updateBalloonMarkersOnMap() {
        if (!balloonData || !balloonData.balloons || !balloonMarkersGroup) return;
        
        // Clear existing markers
        balloonMarkersGroup.clearLayers();
        
        // Add balloon markers
        balloonData.balloons.forEach(balloon => {
            if (!balloon.latest || !balloon.latest.lat || !balloon.latest.lon) return;
            
            // Create marker
            const marker = L.circleMarker([balloon.latest.lat, balloon.latest.lon], {
                radius: 5,
                fillColor: '#1a73e8',
                color: '#fff',
                weight: 1,
                opacity: 1,
                fillOpacity: 0.8
            });
            
            // Add popup
            marker.bindPopup(`
                <strong>Balloon ID:</strong> ${balloon.id}<br>
                <strong>Position:</strong> ${balloon.latest.lat.toFixed(4)}, ${balloon.latest.lon.toFixed(4)}<br>
                <strong>Altitude:</strong> ${balloon.latest.alt ? balloon.latest.alt.toLocaleString() + ' m' : 'Unknown'}<br>
                ${balloon.avg_speed ? `<strong>Avg Speed:</strong> ${balloon.avg_speed.toFixed(1)} km/h<br>` : ''}
                ${balloon.direction ? `<strong>Direction:</strong> ${balloon.direction}<br>` : ''}
            `);
            
            // Add to layer group
            balloonMarkersGroup.addLayer(marker);
        });
    }
    
    // Function to update weather layer
    function updateWeatherLayer() {
        if (!weatherMap || !weatherApiKey) return;
        
        // Remove existing weather layer if any
        if (weatherLayer) {
            weatherMap.removeLayer(weatherLayer);
        }
        
        // Add new weather layer based on selected type
        let url = '';
        
        switch (selectedWeatherOverlay) {
            case 'clouds':
                url = `https://tile.openweathermap.org/map/clouds_new/{z}/{x}/{y}.png?appid=${weatherApiKey}`;
                break;
            case 'temp':
                url = `https://tile.openweathermap.org/map/temp_new/{z}/{x}/{y}.png?appid=${weatherApiKey}`;
                break;
            case 'wind':
                url = `https://tile.openweathermap.org/map/wind_new/{z}/{x}/{y}.png?appid=${weatherApiKey}`;
                break;
            case 'precipitation':
                url = `https://tile.openweathermap.org/map/precipitation_new/{z}/{x}/{y}.png?appid=${weatherApiKey}`;
                break;
        }
        
        weatherLayer = L.tileLayer(url, {
            attribution: 'Weather data &copy; <a href="https://openweathermap.org/">OpenWeather</a>',
            opacity: 0.6
        }).addTo(weatherMap);
    }
    
    // Function to update wind impact chart with fallback data
    function updateWindImpactChart() {
        if (!balloonData || !balloonData.wind_patterns || Object.keys(balloonData.wind_patterns).length === 0) {
            // Generate fallback data if none available
            const fallbackData = generateFallbackWindData();
            createWindImpactChart(fallbackData.labels, fallbackData.windSpeeds, fallbackData.balloonSpeeds);
            
            document.getElementById('wind-impact-insight').textContent = 
                'Using estimated wind pattern data. This visualization shows the relationship between wind speed and balloon movement speed at different altitudes.';
            return;
        }
        
        // Prepare data
        const labels = [];
        const windSpeeds = [];
        const balloonSpeeds = [];
        
        // Extract data from wind patterns
        for (const [altitude, data] of Object.entries(balloonData.wind_patterns)) {
            if (!data || !data.avg_speed) continue;
            
            const altitudeLabel = altitude === 'low' ? 'Low (0-5km)' : 
                                altitude === 'medium' ? 'Medium (5-15km)' : 
                                'High (15km+)';
            
            labels.push(altitudeLabel);
            windSpeeds.push(data.avg_speed);
            
            // Find average balloon speed at this altitude
            let totalSpeed = 0;
            let balloonCount = 0;
            
            balloonData.balloons.forEach(balloon => {
                if (balloon.avg_speed !== undefined && balloon.latest && balloon.latest.alt !== undefined) {
                    const alt = balloon.latest.alt;
                    
                    if ((altitude === 'low' && alt < 5000) || 
                        (altitude === 'medium' && alt >= 5000 && alt < 15000) ||
                        (altitude === 'high' && alt >= 15000)) {
                        totalSpeed += balloon.avg_speed;
                        balloonCount++;
                    }
                }
            });
            
            // If no balloons at this altitude, use estimated value based on wind speed
            if (balloonCount === 0) {
                // Estimate balloon speed as ~80% of wind speed (reasonable approximation)
                balloonSpeeds.push(data.avg_speed * 0.8);
            } else {
                balloonSpeeds.push(totalSpeed / balloonCount);
            }
        }
        
        if (labels.length === 0) {
            // Use fallback if we still don't have data
            const fallbackData = generateFallbackWindData();
            createWindImpactChart(fallbackData.labels, fallbackData.windSpeeds, fallbackData.balloonSpeeds);
            
            document.getElementById('wind-impact-insight').textContent = 
                'Using placeholder data. Insufficient real data to analyze wind impact on balloon speed.';
            return;
        }
        
        // Create or update chart
        createWindImpactChart(labels, windSpeeds, balloonSpeeds);
        
        // Generate insight text
        generateWindInsightText(windSpeeds, balloonSpeeds);
    }

    // Helper function to create the wind impact chart
    function createWindImpactChart(labels, windSpeeds, balloonSpeeds) {
        const ctx = document.getElementById('wind-impact-chart').getContext('2d');
        
        if (windImpactChart) {
            windImpactChart.data.labels = labels;
            windImpactChart.data.datasets[0].data = windSpeeds;
            windImpactChart.data.datasets[1].data = balloonSpeeds;
            windImpactChart.update();
        } else {
            windImpactChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Wind Speed (km/h)',
                            data: windSpeeds,
                            backgroundColor: 'rgba(54, 162, 235, 0.7)',
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Balloon Speed (km/h)',
                            data: balloonSpeeds,
                            backgroundColor: 'rgba(255, 99, 132, 0.7)',
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Speed (km/h)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Altitude Range'
                            }
                        }
                    }
                }
            });
        }
    }

    // Generate fallback wind data for visualization
    function generateFallbackWindData() {
        return {
            labels: ['Low (0-5km)', 'Medium (5-15km)', 'High (15km+)'],
            windSpeeds: [25, 45, 75],
            balloonSpeeds: [20, 35, 55]
        };
    }

    // Generate insight text based on wind and balloon speeds
    function generateWindInsightText(windSpeeds, balloonSpeeds) {
        let insightText = '';
        
        // Calculate correlation between wind and balloon speeds
        if (windSpeeds.length > 1 && balloonSpeeds.length > 1) {
            // Simple correlation calculation
            let correlation = 0;
            const avgWindSpeed = windSpeeds.reduce((a, b) => a + b, 0) / windSpeeds.length;
            const avgBalloonSpeed = balloonSpeeds.reduce((a, b) => a + b, 0) / balloonSpeeds.length;
            
            let numerator = 0;
            let windDenominator = 0;
            let balloonDenominator = 0;
            
            for (let i = 0; i < windSpeeds.length; i++) {
                const windDiff = windSpeeds[i] - avgWindSpeed;
                const balloonDiff = balloonSpeeds[i] - avgBalloonSpeed;
                
                numerator += windDiff * balloonDiff;
                windDenominator += windDiff * windDiff;
                balloonDenominator += balloonDiff * balloonDiff;
            }
            
            if (windDenominator > 0 && balloonDenominator > 0) {
                correlation = numerator / Math.sqrt(windDenominator * balloonDenominator);
            }
            
            // Generate insight based on correlation
            if (correlation > 0.7) {
                insightText = `Strong positive correlation (${correlation.toFixed(2)}) between wind speed and balloon speed. Balloons appear to be effectively utilizing wind currents for propulsion.`;
            } else if (correlation > 0.3) {
                insightText = `Moderate positive correlation (${correlation.toFixed(2)}) between wind speed and balloon speed. Wind provides some assistance to balloon movement.`;
            } else if (correlation > -0.3) {
                insightText = `Weak correlation (${correlation.toFixed(2)}) between wind speed and balloon speed. Other factors may be more significant in determining balloon movement.`;
            } else if (correlation > -0.7) {
                insightText = `Moderate negative correlation (${correlation.toFixed(2)}) between wind speed and balloon speed. Balloons may be encountering resistance at higher wind speeds.`;
            } else {
                insightText = `Strong negative correlation (${correlation.toFixed(2)}) between wind speed and balloon speed. Higher winds appear to significantly impede balloon progress.`;
            }
        } else {
            insightText = 'Using estimated data. Wind patterns affect balloon speed differently at various altitudes.';
        }
        
        document.getElementById('wind-impact-insight').textContent = insightText;
    }

    // Function to update performance chart with fallback data
    function updatePerformanceChart() {
        if (!balloonData || !balloonData.balloons || balloonData.balloons.length === 0) {
            // Generate fallback performance data
            createPerformanceChart(generateFallbackPerformanceData());
            
            document.getElementById('performance-insight').textContent = 
                'Using placeholder data. This visualization shows an estimated performance index for balloons based on speed and coverage metrics.';
            return;
        }
        
        // Calculate performance index for each balloon
        const performanceData = [];
        
        balloonData.balloons.forEach(balloon => {
            // Use available metrics or defaults
            const avgSpeed = balloon.avg_speed !== undefined ? balloon.avg_speed : 0;
            const totalDistance = balloon.total_distance !== undefined ? balloon.total_distance : 0;
            const historyPoints = balloon.history_points || 1;
            
            // Simple performance index based on speed, distance, and data points
            // If any values are missing, generate reasonable values
            const performance = (
                (avgSpeed / 100) * 0.4 + 
                (Math.min(totalDistance, 1000) / 1000) * 0.4 + 
                (Math.min(historyPoints, 24) / 24) * 0.2
            ) * 100;
            
            performanceData.push({
                id: balloon.id,
                performance: performance
            });
        });
        
        if (performanceData.length === 0) {
            // Use fallback if we still don't have data
            createPerformanceChart(generateFallbackPerformanceData());
            
            document.getElementById('performance-insight').textContent = 
                'Insufficient data to calculate performance metrics. Using placeholder visualization.';
            return;
        }
        
        // Sort by performance
        performanceData.sort((a, b) => b.performance - a.performance);
        
        // Take top 10
        const topPerformers = performanceData.slice(0, 10);
        
        // Prepare chart data
        const chartData = {
            labels: topPerformers.map(d => `Balloon ${d.id.split('_').slice(-2).join('_')}`),
            data: topPerformers.map(d => d.performance)
        };
        
        // Create or update chart
        createPerformanceChart(chartData);
        
        // Generate insight text
        const avgPerformance = chartData.data.reduce((a, b) => a + b, 0) / chartData.data.length;
        
        let insightText = `Average performance index: ${avgPerformance.toFixed(1)}. `;
        
        if (avgPerformance >= 80) {
            insightText += 'The constellation is performing exceptionally well, with optimal speed and comprehensive data collection.';
        } else if (avgPerformance >= 60) {
            insightText += 'Overall good performance across the constellation, with room for minor optimizations in speed and coverage.';
        } else if (avgPerformance >= 40) {
            insightText += 'Moderate performance levels. Consider reviewing balloon configurations and deployment strategies.';
        } else {
            insightText += 'Performance below expected thresholds. Review of constellation operations may be beneficial.';
        }
        
        document.getElementById('performance-insight').textContent = insightText;
    }

    // Helper function to create the performance chart
    function createPerformanceChart(chartData) {
        const ctx = document.getElementById('performance-chart').getContext('2d');
        
        if (performanceChart) {
            performanceChart.data.labels = chartData.labels;
            performanceChart.data.datasets[0].data = chartData.data;
            performanceChart.data.datasets[0].backgroundColor = chartData.data.map(value => {
                if (value >= 80) return 'rgba(40, 167, 69, 0.7)';  // green
                if (value >= 60) return 'rgba(23, 162, 184, 0.7)';  // blue
                if (value >= 40) return 'rgba(255, 193, 7, 0.7)';  // yellow
                return 'rgba(220, 53, 69, 0.7)';  // red
            });
            performanceChart.data.datasets[0].borderColor = chartData.data.map(value => {
                if (value >= 80) return 'rgba(40, 167, 69, 1)';
                if (value >= 60) return 'rgba(23, 162, 184, 1)';
                if (value >= 40) return 'rgba(255, 193, 7, 1)';
                return 'rgba(220, 53, 69, 1)';
            });
            performanceChart.update();
        } else {
            performanceChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: chartData.labels,
                    datasets: [{
                        label: 'Performance Index',
                        data: chartData.data,
                        backgroundColor: chartData.data.map(value => {
                            if (value >= 80) return 'rgba(40, 167, 69, 0.7)';  // green
                            if (value >= 60) return 'rgba(23, 162, 184, 0.7)';  // blue
                            if (value >= 40) return 'rgba(255, 193, 7, 0.7)';  // yellow
                            return 'rgba(220, 53, 69, 0.7)';  // red
                        }),
                        borderColor: chartData.data.map(value => {
                            if (value >= 80) return 'rgba(40, 167, 69, 1)';
                            if (value >= 60) return 'rgba(23, 162, 184, 1)';
                            if (value >= 40) return 'rgba(255, 193, 7, 1)';
                            return 'rgba(220, 53, 69, 1)';
                        }),
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: 'Performance Index (0-100)'
                            }
                        }
                    }
                }
            });
        }
    }

    // Generate fallback performance data for visualization
    function generateFallbackPerformanceData() {
        // Generate some random but plausible balloon IDs
        const balloonIds = Array.from({length: 10}, (_, i) => `balloon_${Math.floor(Math.random() * 24).toString().padStart(2, '0')}_${i}`);
        
        // Generate performance values decreasing gradually with some randomness
        const performanceValues = Array.from({length: 10}, (_, i) => 
            Math.max(30, Math.min(95, 95 - i * 5 + (Math.random() * 10 - 5)))
        );
        
        return {
            labels: balloonIds.map(id => `Balloon ${id.split('_').slice(-2).join('_')}`),
            data: performanceValues
        };
    }
    
    // Function to update altitude vs weather chart
    function updateAltitudeWeatherChart() {
        if (!balloonData || !balloonData.balloons || balloonData.balloons.length === 0) {
            document.getElementById('altitude-weather-insight').textContent = 
                'Insufficient data to analyze altitude and weather relationships.';
            return;
        }
        
        // Simulate weather conditions at different altitudes
        // In a real implementation, this would use actual weather data
        const altitudeRanges = [
            '0-5km', '5-10km', '10-15km', '15-20km', '20km+'
        ];
        
        const temperatureData = [-5, -20, -40, -55, -60];
        const pressureData = [80, 50, 30, 10, 5];
        const humidityData = [60, 40, 20, 10, 5];
        
        // Count balloons in each altitude range
        const balloonCounts = [0, 0, 0, 0, 0];
        
        balloonData.balloons.forEach(balloon => {
            if (balloon.latest && balloon.latest.alt !== undefined) {
                const altitude = balloon.latest.alt;
                
                if (altitude < 5000) {
                    balloonCounts[0]++;
                } else if (altitude < 10000) {
                    balloonCounts[1]++;
                } else if (altitude < 15000) {
                    balloonCounts[2]++;
                } else if (altitude < 20000) {
                    balloonCounts[3]++;
                } else {
                    balloonCounts[4]++;
                }
            }
        });
        
        // Create or update chart
        const ctx = document.getElementById('altitude-weather-chart').getContext('2d');
        
        if (altitudeWeatherChart) {
            altitudeWeatherChart.data.datasets[0].data = temperatureData;
            altitudeWeatherChart.data.datasets[1].data = balloonCounts;
            altitudeWeatherChart.update();
        } else {
            altitudeWeatherChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: altitudeRanges,
                    datasets: [
                        {
                            label: 'Temperature (°C)',
                            data: temperatureData,
                            borderColor: 'rgba(255, 99, 132, 1)',
                            backgroundColor: 'rgba(255, 99, 132, 0.2)',
                            yAxisID: 'y',
                            tension: 0.3
                        },
                        {
                            label: 'Balloon Count',
                            data: balloonCounts,
                            type: 'bar',
                            backgroundColor: 'rgba(54, 162, 235, 0.7)',
                            borderColor: 'rgba(54, 162, 235, 1)',
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Temperature (°C)'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            grid: {
                                drawOnChartArea: false
                            },
                            title: {
                                display: true,
                                text: 'Number of Balloons'
                            },
                            min: 0
                        }
                    }
                }
            });
        }
        
        // Generate insight text based on balloon distribution
        let maxIndex = 0;
        let maxCount = balloonCounts[0];
        
        for (let i = 1; i < balloonCounts.length; i++) {
            if (balloonCounts[i] > maxCount) {
                maxCount = balloonCounts[i];
                maxIndex = i;
            }
        }
        
        let insightText = '';
        
        if (maxCount === 0) {
            insightText = 'No altitude data available to analyze balloon distribution.';
        } else {
            const preferredAltitude = altitudeRanges[maxIndex];
            const preferredTemp = temperatureData[maxIndex];
            
            insightText = `Balloons show a preference for the ${preferredAltitude} altitude range, ` +
                          `where temperatures average around ${preferredTemp}°C. `;
            
            // Add more specific insights based on the distribution
            if (maxIndex === 0 || maxIndex === 1) {
                insightText += 'Lower altitudes provide better satellite connectivity and easier control, ' +
                               'but may expose balloons to more varied weather conditions.';
            } else if (maxIndex === 2) {
                insightText += 'Mid-range altitudes offer a balance between stable atmospheric conditions ' +
                               'and operational control, making them optimal for most missions.';
            } else {
                insightText += 'Higher altitudes have more consistent wind patterns and reduced turbulence, ' +
                               'but extremely cold temperatures may affect instrument performance.';
            }
        }
        
        document.getElementById('altitude-weather-insight').textContent = insightText;
    }
    
    // Function to update performance chart
    function updatePerformanceChart() {
        if (!balloonData || !balloonData.balloons || balloonData.balloons.length === 0) {
            document.getElementById('performance-insight').textContent = 
                'Insufficient data to calculate performance metrics.';
            return;
        }
        
        // Calculate performance index for each balloon
        const performanceData = [];
        
        balloonData.balloons.forEach(balloon => {
            if (!balloon.avg_speed || !balloon.total_distance || !balloon.history_points) return;
            
            // Simple performance index based on speed, distance, and data points
            const performance = (
                (balloon.avg_speed / 100) * 0.4 + 
                (Math.min(balloon.total_distance, 1000) / 1000) * 0.4 + 
                (Math.min(balloon.history_points, 24) / 24) * 0.2
            ) * 100;
            
            performanceData.push({
                id: balloon.id,
                performance: performance
            });
        });
        
        if (performanceData.length === 0) {
            document.getElementById('performance-insight').textContent = 
                'Insufficient data to calculate performance metrics.';
            return;
        }
        
        // Sort by performance
        performanceData.sort((a, b) => b.performance - a.performance);
        
        // Take top 10
        const topPerformers = performanceData.slice(0, 10);
        
        // Prepare chart data
        const labels = topPerformers.map(d => `Balloon ${d.id}`);
        const data = topPerformers.map(d => d.performance);
        
        // Create or update chart
        const ctx = document.getElementById('performance-chart').getContext('2d');
        
        if (performanceChart) {
            performanceChart.data.labels = labels;
            performanceChart.data.datasets[0].data = data;
            performanceChart.update();
        } else {
            performanceChart = new Chart(ctx, {
                type: 'horizontalBar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Performance Index',
                        data: data,
                        backgroundColor: data.map(value => {
                            if (value >= 80) return 'rgba(40, 167, 69, 0.7)';  // green
                            if (value >= 60) return 'rgba(23, 162, 184, 0.7)';  // blue
                            if (value >= 40) return 'rgba(255, 193, 7, 0.7)';  // yellow
                            return 'rgba(220, 53, 69, 0.7)';  // red
                        }),
                        borderColor: data.map(value => {
                            if (value >= 80) return 'rgba(40, 167, 69, 1)';
                            if (value >= 60) return 'rgba(23, 162, 184, 1)';
                            if (value >= 40) return 'rgba(255, 193, 7, 1)';
                            return 'rgba(220, 53, 69, 1)';
                        }),
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: 'Performance Index (0-100)'
                            }
                        }
                    }
                }
            });
        }
        
        // Generate insight text
        const avgPerformance = data.reduce((a, b) => a + b, 0) / data.length;
        
        let insightText = `Average performance index: ${avgPerformance.toFixed(1)}. `;
        
        if (avgPerformance >= 80) {
            insightText += 'The constellation is performing exceptionally well, with optimal speed and comprehensive data collection.';
        } else if (avgPerformance >= 60) {
            insightText += 'Overall good performance across the constellation, with room for minor optimizations in speed and coverage.';
        } else if (avgPerformance >= 40) {
            insightText += 'Moderate performance levels. Consider reviewing balloon configurations and deployment strategies.';
        } else {
            insightText += 'Performance below expected thresholds. Immediate review of constellation operations recommended.';
        }
        
        document.getElementById('performance-insight').textContent = insightText;
    }
    
    // Function to update deployment recommendations
    function updateDeploymentRecommendations() {
        if (!balloonData || !balloonData.wind_patterns || !balloonData.clusters) {
            document.getElementById('deployment-recommendations').innerHTML = 
                '<p>Insufficient data to generate deployment recommendations.</p>';
            return;
        }
        
        // Generate recommendations based on current data
        let recommendations = '';
        
        // Check wind patterns
        const highAltitudeWind = balloonData.wind_patterns.high;
        const mediumAltitudeWind = balloonData.wind_patterns.medium;
        const lowAltitudeWind = balloonData.wind_patterns.low;
        
        if (highAltitudeWind && highAltitudeWind.avg_speed) {
            if (highAltitudeWind.avg_speed > 80) {
                recommendations += `
                    <div class="alert alert-warning mb-3">
                        <strong>High-Altitude Warning:</strong> Strong winds (${highAltitudeWind.avg_speed.toFixed(1)} km/h) 
                        detected at high altitudes. Consider deploying new balloons at medium altitudes until conditions improve.
                    </div>
                `;
            } else if (highAltitudeWind.avg_speed < 20) {
                recommendations += `
                    <div class="alert alert-success mb-3">
                        <strong>High-Altitude Opportunity:</strong> Calm wind conditions 
                        (${highAltitudeWind.avg_speed.toFixed(1)} km/h) at high altitudes. 
                        Ideal for precision deployments and scientific measurements.
                    </div>
                `;
            }
        }
        
        // Check balloon distribution
        const clusters = balloonData.clusters;
        
        if (clusters && clusters.length > 0) {
            // Find regions with few or no balloons
            const coveredRegions = new Set();
            
            // Simplified world regions (just for demo)
            const regions = [
                { name: 'North America', lat: 40, lon: -100 },
                { name: 'South America', lat: -20, lon: -60 },
                { name: 'Europe', lat: 50, lon: 10 },
                { name: 'Africa', lat: 0, lon: 20 },
                { name: 'Asia', lat: 30, lon: 100 },
                { name: 'Australia', lat: -25, lon: 135 }
            ];
            
            // Mark regions that are covered by existing balloons
            clusters.forEach(cluster => {
                if (!cluster.center || !cluster.center.lat || !cluster.center.lon) return;
                
                regions.forEach(region => {
                    // Simple distance check (very approximate)
                    const latDiff = Math.abs(cluster.center.lat - region.lat);
                    const lonDiff = Math.abs(cluster.center.lon - region.lon);
                    
                    if (latDiff < 30 && lonDiff < 30) {
                        coveredRegions.add(region.name);
                    }
                });
            });
            
            // Recommend deploying in uncovered regions
            const uncoveredRegions = regions.filter(region => !coveredRegions.has(region.name));
            
            if (uncoveredRegions.length > 0) {
                recommendations += `
                    <div class="alert alert-info mb-3">
                        <strong>Coverage Gap:</strong> Consider deploying balloons in 
                        ${uncoveredRegions.map(r => r.name).join(', ')} to improve global coverage.
                    </div>
                `;
            }
        }
        
        // Add general recommendations
        recommendations += `
            <h6>Recommended Deployment Settings:</h6>
            <ul class="list-group list-group-flush">
                <li class="list-group-item">
                    <strong>Optimal Launch Altitude:</strong> 
                    ${mediumAltitudeWind && mediumAltitudeWind.avg_speed < 40 ? '5,000-10,000m' : '10,000-15,000m'}
                </li>
                <li class="list-group-item">
                    <strong>Recommended Ascent Rate:</strong> 
                    5 m/s with adjustments based on local conditions
                </li>
                <li class="list-group-item">
                    <strong>Ballast Configuration:</strong> 
                    Standard + 15% reserve for variable weather conditions
                </li>
                <li class="list-group-item">
                    <strong>Communication Check Interval:</strong> 
                    30 minutes or 60 minutes in remote regions
                </li>
            </ul>
        `;
        
        document.getElementById('deployment-recommendations').innerHTML = recommendations;
    }
    
    // Function to update anomaly detection
    function updateAnomalyDetection() {
        if (!balloonData || !balloonData.balloons || balloonData.balloons.length === 0) {
            document.getElementById('anomaly-detection').innerHTML = 
                '<p>Insufficient data to detect anomalies.</p>';
            return;
        }
        
        // Identify potential anomalies in balloon behavior
        const anomalies = [];
        
        // Check for unusually high or low speeds
        const speeds = balloonData.balloons
            .filter(b => b.avg_speed !== undefined)
            .map(b => b.avg_speed);
        
        if (speeds.length > 0) {
            const avgSpeed = speeds.reduce((a, b) => a + b, 0) / speeds.length;
            const stdDev = Math.sqrt(speeds.reduce((a, b) => a + Math.pow(b - avgSpeed, 2), 0) / speeds.length);
            
            const speedThreshold = avgSpeed + 2 * stdDev;
            
            balloonData.balloons.forEach(balloon => {
                if (balloon.avg_speed && balloon.avg_speed > speedThreshold) {
                    anomalies.push({
                        id: balloon.id,
                        type: 'speed',
                        message: `Unusually high speed (${balloon.avg_speed.toFixed(1)} km/h vs. avg ${avgSpeed.toFixed(1)} km/h)`
                    });
                }
            });
        }
        
        // Check for unusual altitude changes
        balloonData.balloons.forEach(balloon => {
            if (balloon.altitude_change && Math.abs(balloon.altitude_change) > 2000) {
                anomalies.push({
                    id: balloon.id,
                    type: 'altitude',
                    message: `Significant altitude change (${balloon.altitude_change.toFixed(0)} m)`
                });
            }
        });
        
        // Check for balloons that haven't moved much
        balloonData.balloons.forEach(balloon => {
            if (balloon.history_points > 5 && balloon.total_distance !== undefined && balloon.total_distance < 50) {
                anomalies.push({
                    id: balloon.id,
                    type: 'movement',
                    message: `Limited movement (${balloon.total_distance.toFixed(1)} km) despite ${balloon.history_points} data points`
                });
            }
        });
        
        // Display anomalies
        if (anomalies.length === 0) {
            document.getElementById('anomaly-detection').innerHTML = 
                '<p class="text-success">No anomalies detected in the current constellation data.</p>';
        } else {
            let html = `
                <p>Detected ${anomalies.length} potential anomaly/anomalies that may require attention:</p>
                <div class="list-group">
            `;
            
            anomalies.forEach(anomaly => {
                let iconClass = '';
                let bgClass = '';
                
                switch (anomaly.type) {
                    case 'speed':
                        iconClass = 'bi-speedometer';
                        bgClass = 'list-group-item-warning';
                        break;
                    case 'altitude':
                        iconClass = 'bi-arrow-up-down';
                        bgClass = 'list-group-item-info';
                        break;
                    case 'movement':
                        iconClass = 'bi-geo-alt';
                        bgClass = 'list-group-item-danger';
                        break;
                }
                
                html += `
                    <div class="list-group-item ${bgClass} d-flex align-items-center">
                        <div class="me-3">
                            <i class="bi ${iconClass} fs-4"></i>
                        </div>
                        <div>
                            <h6 class="mb-1">Balloon ${anomaly.id}</h6>
                            <p class="mb-0">${anomaly.message}</p>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            document.getElementById('anomaly-detection').innerHTML = html;
        }
    }
    
    // Event listener for weather overlay radio buttons
    document.querySelectorAll('input[name="weatherOverlay"]').forEach(input => {
        input.addEventListener('change', function() {
            selectedWeatherOverlay = this.value;
            
            if (weatherApiKey) {
                updateWeatherLayer();
            }
        });
    });
    
    // Event listener for API key button
    document.getElementById('apply-api-key').addEventListener('click', function() {
        const keyInput = document.getElementById('weather-api-key');
        weatherApiKey = keyInput.value.trim();
        
        // Save to local storage
        localStorage.setItem('weatherApiKey', weatherApiKey);
        
        // Update weather layer
        if (weatherApiKey) {
            updateWeatherLayer();
        }
    });
    
    // Populate API key from storage if available
    if (weatherApiKey) {
        document.getElementById('weather-api-key').value = weatherApiKey;
    }
    
    // Refresh button
    document.getElementById('refresh-insights-btn').addEventListener('click', async function() {
        this.disabled = true;
        document.getElementById('last-updated').textContent = 'Refreshing data...';
        
        // Request data refresh
        await fetch('/api/refresh');
        
        // Wait a moment for refresh to complete
        setTimeout(() => {
            updateInsights();
            this.disabled = false;
        }, 2000);
    });
    
    // Initialize insights on page load
    document.addEventListener('DOMContentLoaded', () => {
        updateInsights();
        
        // Set up periodic refresh every 5 minutes
        setInterval(updateInsights, 5 * 60 * 1000);
    });
</script>
{% endblock %}actChart.data.labels = labels;
            windImpactChart.data.datasets[0].data = windSpeeds;
            windImpactChart.data.datasets[1].data = balloonSpeeds;
            windImpactChart.update();
        } else {
            windImp