{% extends "base.html" %}

{% block title %}Insights - Windborne Constellation Tracker{% endblock %}

{% block extra_css %}
<style>
    .insight-card {
        transition: transform 0.3s ease;
        height: 100%;
    }
    
    .insight-card:hover {
        transform: translateY(-5px);
    }
    
    .chart-container {
        height: 300px;
        position: relative;
    }
    
    .notes-section {
        background-color: #f8f9fa;
        border-left: 4px solid #0d6efd;
        padding: 15px;
        margin-bottom: 20px;
    }
    
    #weather-map {
        height: 400px;
    }
    
    .openweather-api-section {
        background-color: rgba(255, 255, 255, 0.9);
        padding: 15px;
        border-radius: 5px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
    }
    
    .weather-overlay-options {
        margin-top: 10px;
    }
    
    #api-key-input {
        max-width: 350px;
    }
</style>
{% endblock %}

{% block content %}
<div class="row mb-3">
    <div class="col-12">
        <div class="d-flex justify-content-between align-items-center">
            <h1>Operational Insights</h1>
            <div>
                <button id="refresh-insights-btn" class="btn btn-outline-primary">
                    <i class="bi bi-arrow-clockwise"></i> Refresh
                </button>
                <small id="last-updated" class="text-muted ms-2">Last updated: Loading...</small>
            </div>
        </div>
    </div>
</div>

<div class="row mb-4">
    <div class="col-12">
        <div class="notes-section">
            <h5>Project Notes</h5>
            <p>
                This project combines Windborne's balloon constellation data with weather information 
                to provide operational insights for fleet management. By correlating balloon 
                positions with real-time weather data, we can identify patterns that affect 
                balloon performance, predict potential flight risks, and optimize future deployments.
            </p>
            <p>
                <strong>Why this approach?</strong> Understanding the interaction between atmospheric 
                conditions and balloon behavior helps Windborne optimize flight paths, improve 
                balloon longevity, and enhance the quality of collected data. This interface 
                provides both strategic overview and detailed balloon-specific insights.
            </p>
        </div>
    </div>
</div>

<div class="row mb-4">
    <div class="col-12">
        <div class="card">
            <div class="card-header">
                <h5 class="card-title mb-0">Weather and Balloon Integration</h5>
            </div>
            <div class="card-body">
                <div class="openweather-api-section">
                    <h6>OpenWeather API Integration</h6>
                    <p>
                        Visualize balloon positions alongside real-time weather data. 
                        This feature requires an OpenWeather API key to fetch current weather conditions.
                    </p>
                    <div class="row align-items-center">
                        <div class="col-md-6">
                            <div class="input-group mb-3" id="api-key-input">
                                <input type="text" class="form-control" id="weather-api-key" placeholder="Enter OpenWeather API Key">
                                <button class="btn btn-outline-primary" type="button" id="apply-api-key">Apply</button>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="weather-overlay-options">
                                <div class="form-check form-check-inline">
                                    <input class="form-check-input" type="radio" name="weatherOverlay" id="clouds-overlay" value="clouds" checked>
                                    <label class="form-check-label" for="clouds-overlay">Clouds</label>
                                </div>
                                <div class="form-check form-check-inline">
                                    <input class="form-check-input" type="radio" name="weatherOverlay" id="temp-overlay" value="temp">
                                    <label class="form-check-label" for="temp-overlay">Temperature</label>
                                </div>
                                <div class="form-check form-check-inline">
                                    <input class="form-check-input" type="radio" name="weatherOverlay" id="wind-overlay" value="wind">
                                    <label class="form-check-label" for="wind-overlay">Wind</label>
                                </div>
                                <div class="form-check form-check-inline">
                                    <input class="form-check-input" type="radio" name="weatherOverlay" id="precipitation-overlay" value="precipitation">
                                    <label class="form-check-label" for="precipitation-overlay">Precipitation</label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="weather-map"></div>
            </div>
        </div>
    </div>
</div>

<div class="row mb-4">
    <div class="col-md-6">
        <div class="card insight-card">
            <div class="card-header">
                <h5 class="card-title mb-0">Wind Impact on Balloon Speed</h5>
            </div>
            <div class="card-body">
                <div class="chart-container">
                    <canvas id="wind-impact-chart"></canvas>
                </div>
                <div class="mt-3">
                    <p id="wind-impact-insight">Loading analysis...</p>
                </div>
            </div>
        </div>
    </div>
    <div class="col-md-6">
        <div class="card insight-card">
            <div class="card-header">
                <h5 class="card-title mb-0">Altitude vs. Weather Conditions</h5>
            </div>
            <div class="card-body">
                <div class="chart-container">
                    <canvas id="altitude-weather-chart"></canvas>
                </div>
                <div class="mt-3">
                    <p id="altitude-weather-insight">Loading analysis...</p>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="row">
    <div class="col-md-4">
        <div class="card insight-card">
            <div class="card-header">
                <h5 class="card-title mb-0">Balloon Performance Index</h5>
            </div>
            <div class="card-body">
                <div class="chart-container">
                    <canvas id="performance-chart"></canvas>
                </div>
                <div class="mt-3">
                    <p id="performance-insight">Loading analysis...</p>
                </div>
            </div>
        </div>
    </div>
    <div class="col-md-4">
        <div class="card insight-card">
            <div class="card-header">
                <h5 class="card-title mb-0">Deployment Recommendations</h5>
            </div>
            <div class="card-body">
                <div id="deployment-recommendations">
                    <div class="d-flex align-items-center mb-3">
                        <div class="spinner-border text-primary me-2" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <span>Generating recommendations...</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="col-md-4">
        <div class="card insight-card">
            <div class="card-header">
                <h5 class="card-title mb-0">Anomaly Detection</h5>
            </div>
            <div class="card-body">
                <div id="anomaly-detection">
                    <div class="d-flex align-items-center mb-3">
                        <div class="spinner-border text-primary me-2" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <span>Analyzing balloon patterns...</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    // Global variables
    let balloonData = null;
    let weatherApiKey = localStorage.getItem('weatherApiKey') || '';
    let selectedWeatherOverlay = 'clouds';
    let weatherMap = null;
    let balloonMarkersGroup = null;
    let weatherLayer = null;
    
    // Chart instances
    let windImpactChart = null;
    let altitudeWeatherChart = null;
    let performanceChart = null;
    
    // Function to update insights with latest data
    async function updateInsights() {
        try {
            // Fetch balloon data from our API
            const response = await fetch('/api/balloons');
            balloonData = await response.json();
            
            if (!balloonData) {
                console.error('No data received from API');
                return;
            }
            
            // Update last updated time
            document.getElementById('last-updated').textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
            
            // Initialize or update weather map
            initializeWeatherMap();
            
            // Update charts and insights
            updateWindImpactChart();
            updateAltitudeWeatherChart();
            updatePerformanceChart();
            updateDeploymentRecommendations();
            updateAnomalyDetection();
            
        } catch (error) {
            console.error('Error updating insights:', error);
        }
    }
    
    // Function to initialize weather map
    function initializeWeatherMap() {
        if (!weatherMap) {
            // Initialize map
            weatherMap = L.map('weather-map').setView([20, 0], 2);
            
            // Add the base map layer
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(weatherMap);
            
            // Create balloon markers layer group
            balloonMarkersGroup = L.layerGroup().addTo(weatherMap);
        }
        
        // Update balloon markers
        updateBalloonMarkersOnMap();
        
        // Update weather layer if API key is available
        if (weatherApiKey) {
            updateWeatherLayer();
        }
    }
    
    // Function to update balloon markers on the map
    function updateBalloonMarkersOnMap() {
        if (!balloonData || !balloonData.balloons || !balloonMarkersGroup) return;
        
        // Clear existing markers
        balloonMarkersGroup.clearLayers();
        
        // Add balloon markers
        balloonData.balloons.forEach(balloon => {
            if (!balloon.latest || !balloon.latest.lat || !balloon.latest.lon) return;
            
            // Create marker
            const marker = L.circleMarker([balloon.latest.lat, balloon.latest.lon], {
                radius: 5,
                fillColor: '#1a73e8',
                color: '#fff',
                weight: 1,
                opacity: 1,
                fillOpacity: 0.8
            });
            
            // Add popup
            marker.bindPopup(`
                <strong>Balloon ID:</strong> ${balloon.id}<br>
                <strong>Position:</strong> ${balloon.latest.lat.toFixed(4)}, ${balloon.latest.lon.toFixed(4)}<br>
                <strong>Altitude:</strong> ${balloon.latest.alt ? balloon.latest.alt.toLocaleString() + ' m' : 'Unknown'}<br>
                ${balloon.avg_speed ? `<strong>Avg Speed:</strong> ${balloon.avg_speed.toFixed(1)} km/h<br>` : ''}
                ${balloon.direction ? `<strong>Direction:</strong> ${balloon.direction}<br>` : ''}
            `);
            
            // Add to layer group
            balloonMarkersGroup.addLayer(marker);
        });
    }
    
    // Function to update weather layer
    function updateWeatherLayer() {
        if (!weatherMap || !weatherApiKey) return;
        
        // Remove existing weather layer if any
        if (weatherLayer) {
            weatherMap.removeLayer(weatherLayer);
        }
        
        // Add new weather layer based on selected type
        let url = '';
        
        switch (selectedWeatherOverlay) {
            case 'clouds':
                url = `https://tile.openweathermap.org/map/clouds_new/{z}/{x}/{y}.png?appid=${weatherApiKey}`;
                break;
            case 'temp':
                url = `https://tile.openweathermap.org/map/temp_new/{z}/{x}/{y}.png?appid=${weatherApiKey}`;
                break;
            case 'wind':
                url = `https://tile.openweathermap.org/map/wind_new/{z}/{x}/{y}.png?appid=${weatherApiKey}`;
                break;
            case 'precipitation':
                url = `https://tile.openweathermap.org/map/precipitation_new/{z}/{x}/{y}.png?appid=${weatherApiKey}`;
                break;
        }
        
        weatherLayer = L.tileLayer(url, {
            attribution: 'Weather data &copy; <a href="https://openweathermap.org/">OpenWeather</a>',
            opacity: 0.6
        }).addTo(weatherMap);
    }
    
    // Function to update wind impact chart with fallback data
    function updateWindImpactChart() {
        if (!balloonData || !balloonData.wind_patterns || Object.keys(balloonData.wind_patterns).length === 0) {
            console.log('No wind pattern data available for chart');
            return;
        }
        
        console.log('Updating wind impact chart with data:', balloonData.wind_patterns);
        
        // Prepare data
        const labels = [];
        const windSpeeds = [];
        const balloonSpeeds = [];
        
        // Extract data from wind patterns
        for (const [altitude, data] of Object.entries(balloonData.wind_patterns)) {
            if (!data || !data.avg_speed) {
                console.log(`Skipping ${altitude} due to missing data`);
                continue;
            }
            
            const altitudeLabel = altitude === 'low' ? 'Low (0-5km)' : 
                                altitude === 'medium' ? 'Medium (5-15km)' : 
                                'High (15km+)';
            
            console.log(`Processing ${altitudeLabel} with wind speed ${data.avg_speed}`);
            
            labels.push(altitudeLabel);
            windSpeeds.push(data.avg_speed);
            
            // Find average balloon speed at this altitude
            let totalSpeed = 0;
            let balloonCount = 0;
            
            if (balloonData.balloons && balloonData.balloons.length > 0) {
                balloonData.balloons.forEach(balloon => {
                    if (balloon.avg_speed !== undefined && !isNaN(parseFloat(balloon.avg_speed)) && 
                        balloon.latest && balloon.latest.alt !== undefined && !isNaN(parseFloat(balloon.latest.alt))) {
                        
                        const speed = parseFloat(balloon.avg_speed);
                        const alt = parseFloat(balloon.latest.alt);
                        
                        if ((altitude === 'low' && alt < 5000) || 
                            (altitude === 'medium' && alt >= 5000 && alt < 15000) ||
                            (altitude === 'high' && alt >= 15000)) {
                            totalSpeed += speed;
                            balloonCount++;
                            console.log(`Added balloon ${balloon.id} with speed ${speed} at altitude ${alt}m`);
                        }
                    }
                });
            }
            
            // Calculate average balloon speed for this altitude range
            if (balloonCount > 0) {
                const avgSpeed = totalSpeed / balloonCount;
                balloonSpeeds.push(avgSpeed);
                console.log(`Average balloon speed at ${altitudeLabel}: ${avgSpeed} based on ${balloonCount} balloons`);
            } else {
                // If no balloons found in this range, calculate from wind speed
                // We know that balloons often move at about 80-95% of wind speed
                const estimatedSpeed = data.avg_speed * 0.85;
                balloonSpeeds.push(estimatedSpeed);
                console.log(`Estimated balloon speed at ${altitudeLabel}: ${estimatedSpeed} (no balloons at this altitude)`);
            }
        }
        
        if (labels.length === 0) {
            console.log('No valid data for wind impact chart');
            return;
        }
        
        // Create or update chart
        const ctx = document.getElementById('wind-impact-chart').getContext('2d');
        
        if (windImpactChart) {
            windImpactChart.data.labels = labels;
            windImpactChart.data.datasets[0].data = windSpeeds;
            windImpactChart.data.datasets[1].data = balloonSpeeds;
            windImpactChart.update();
            console.log('Updated existing wind impact chart');
        } else {
            console.log('Creating new wind impact chart');
            windImpactChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Wind Speed (km/h)',
                            data: windSpeeds,
                            backgroundColor: 'rgba(54, 162, 235, 0.7)',
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Balloon Speed (km/h)',
                            data: balloonSpeeds,
                            backgroundColor: 'rgba(255, 99, 132, 0.7)',
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Speed (km/h)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Altitude Range'
                            }
                        }
                    }
                }
            });
        }
        
        // Generate insight text based on wind and balloon speeds
        generateWindInsightText(windSpeeds, balloonSpeeds);
    }

    // Helper function to create the wind impact chart
    function createWindImpactChart(labels, windSpeeds, balloonSpeeds) {
        const ctx = document.getElementById('wind-impact-chart').getContext('2d');
        
        if (windImpactChart) {
            windImpactChart.data.labels = labels;
            windImpactChart.data.datasets[0].data = windSpeeds;
            windImpactChart.data.datasets[1].data = balloonSpeeds;
            windImpactChart.update();
        } else {
            windImpactChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Wind Speed (km/h)',
                            data: windSpeeds,
                            backgroundColor: 'rgba(54, 162, 235, 0.7)',
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Balloon Speed (km/h)',
                            data: balloonSpeeds,
                            backgroundColor: 'rgba(255, 99, 132, 0.7)',
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Speed (km/h)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Altitude Range'
                            }
                        }
                    }
                }
            });
        }
    }

    // Generate fallback wind data for visualization
    function generateFallbackWindData() {
        return {
            labels: ['Low (0-5km)', 'Medium (5-15km)', 'High (15km+)'],
            windSpeeds: [25, 45, 75],
            balloonSpeeds: [20, 35, 55]
        };
    }

    // Generate insight text based on wind and balloon speeds
    function generateWindInsightText(windSpeeds, balloonSpeeds) {
        let insightText = '';
        
        // Calculate correlation between wind and balloon speeds
        if (windSpeeds.length > 1 && balloonSpeeds.length > 1) {
            // Simple correlation calculation
            let correlation = 0;
            const avgWindSpeed = windSpeeds.reduce((a, b) => a + b, 0) / windSpeeds.length;
            const avgBalloonSpeed = balloonSpeeds.reduce((a, b) => a + b, 0) / balloonSpeeds.length;
            
            let numerator = 0;
            let windDenominator = 0;
            let balloonDenominator = 0;
            
            for (let i = 0; i < windSpeeds.length; i++) {
                const windDiff = windSpeeds[i] - avgWindSpeed;
                const balloonDiff = balloonSpeeds[i] - avgBalloonSpeed;
                
                numerator += windDiff * balloonDiff;
                windDenominator += windDiff * windDiff;
                balloonDenominator += balloonDiff * balloonDiff;
            }
            
            if (windDenominator > 0 && balloonDenominator > 0) {
                correlation = numerator / Math.sqrt(windDenominator * balloonDenominator);
            }
            
            // Generate insight based on correlation
            if (correlation > 0.7) {
                insightText = `Strong positive correlation (${correlation.toFixed(2)}) between wind speed and balloon speed. Balloons appear to be effectively utilizing wind currents for propulsion.`;
            } else if (correlation > 0.3) {
                insightText = `Moderate positive correlation (${correlation.toFixed(2)}) between wind speed and balloon speed. Wind provides some assistance to balloon movement.`;
            } else if (correlation > -0.3) {
                insightText = `Weak correlation (${correlation.toFixed(2)}) between wind speed and balloon speed. Other factors may be more significant in determining balloon movement.`;
            } else if (correlation > -0.7) {
                insightText = `Moderate negative correlation (${correlation.toFixed(2)}) between wind speed and balloon speed. Balloons may be encountering resistance at higher wind speeds.`;
            } else {
                insightText = `Strong negative correlation (${correlation.toFixed(2)}) between wind speed and balloon speed. Higher winds appear to significantly impede balloon progress.`;
            }
        } else {
            insightText = 'Using estimated data. Wind patterns affect balloon speed differently at various altitudes.';
        }
        
        document.getElementById('wind-impact-insight').textContent = insightText;
    }

    // Function to update performance chart with fallback data
    function updatePerformanceChart() {
        if (!balloonData || !balloonData.balloons || balloonData.balloons.length === 0) {
            // Generate fallback performance data
            createPerformanceChart(generateFallbackPerformanceData());
            
            document.getElementById('performance-insight').textContent = 
                'Using placeholder data. This visualization shows an estimated performance index for balloons based on speed and coverage metrics.';
            return;
        }
        
        // Calculate performance index for each balloon
        const performanceData = [];
        
        balloonData.balloons.forEach(balloon => {
            // Use available metrics or defaults
            const avgSpeed = balloon.avg_speed !== undefined ? balloon.avg_speed : 0;
            const totalDistance = balloon.total_distance !== undefined ? balloon.total_distance : 0;
            const historyPoints = balloon.history_points || 1;
            
            // Simple performance index based on speed, distance, and data points
            // If any values are missing, generate reasonable values
            const performance = (
                (avgSpeed / 100) * 0.4 + 
                (Math.min(totalDistance, 1000) / 1000) * 0.4 + 
                (Math.min(historyPoints, 24) / 24) * 0.2
            ) * 100;
            
            performanceData.push({
                id: balloon.id,
                performance: performance
            });
        });
        
        if (performanceData.length === 0) {
            // Use fallback if we still don't have data
            createPerformanceChart(generateFallbackPerformanceData());
            
            document.getElementById('performance-insight').textContent = 
                'Insufficient data to calculate performance metrics. Using placeholder visualization.';
            return;
        }
        
        // Sort by performance
        performanceData.sort((a, b) => b.performance - a.performance);
        
        // Take top 10
        const topPerformers = performanceData.slice(0, 10);
        
        // Prepare chart data
        const chartData = {
            labels: topPerformers.map(d => `Balloon ${d.id.split('_').slice(-2).join('_')}`),
            data: topPerformers.map(d => d.performance)
        };
        
        // Create or update chart
        createPerformanceChart(chartData);
        
        // Generate insight text
        const avgPerformance = chartData.data.reduce((a, b) => a + b, 0) / chartData.data.length;
        
        let insightText = `Average performance index: ${avgPerformance.toFixed(1)}. `;
        
        if (avgPerformance >= 80) {
            insightText += 'The constellation is performing exceptionally well, with optimal speed and comprehensive data collection.';
        } else if (avgPerformance >= 60) {
            insightText += 'Overall good performance across the constellation, with room for minor optimizations in speed and coverage.';
        } else if (avgPerformance >= 40) {
            insightText += 'Moderate performance levels. Consider reviewing balloon configurations and deployment strategies.';
        } else {
            insightText += 'Performance below expected thresholds. Review of constellation operations may be beneficial.';
        }
        
        document.getElementById('performance-insight').textContent = insightText;
    }

    // Helper function to create the performance chart
    function createPerformanceChart(chartData) {
        const ctx = document.getElementById('performance-chart').getContext('2d');
        
        if (performanceChart) {
            performanceChart.data.labels = chartData.labels;
            performanceChart.data.datasets[0].data = chartData.data;
            performanceChart.data.datasets[0].backgroundColor = chartData.data.map(value => {
                if (value >= 80) return 'rgba(40, 167, 69, 0.7)';  // green
                if (value >= 60) return 'rgba(23, 162, 184, 0.7)';  // blue
                if (value >= 40) return 'rgba(255, 193, 7, 0.7)';  // yellow
                return 'rgba(220, 53, 69, 0.7)';  // red
            });
            performanceChart.data.datasets[0].borderColor = chartData.data.map(value => {
                if (value >= 80) return 'rgba(40, 167, 69, 1)';
                if (value >= 60) return 'rgba(23, 162, 184, 1)';
                if (value >= 40) return 'rgba(255, 193, 7, 1)';
                return 'rgba(220, 53, 69, 1)';
            });
            performanceChart.update();
        } else {
            performanceChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: chartData.labels,
                    datasets: [{
                        label: 'Performance Index',
                        data: chartData.data,
                        backgroundColor: chartData.data.map(value => {
                            if (value >= 80) return 'rgba(40, 167, 69, 0.7)';  // green
                            if (value >= 60) return 'rgba(23, 162, 184, 0.7)';  // blue
                            if (value >= 40) return 'rgba(255, 193, 7, 0.7)';  // yellow
                            return 'rgba(220, 53, 69, 0.7)';  // red
                        }),
                        borderColor: chartData.data.map(value => {
                            if (value >= 80) return 'rgba(40, 167, 69, 1)';
                            if (value >= 60) return 'rgba(23, 162, 184, 1)';
                            if (value >= 40) return 'rgba(255, 193, 7, 1)';
                            return 'rgba(220, 53, 69, 1)';
                        }),
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: 'Performance Index (0-100)'
                            }
                        }
                    }
                }
            });
        }
    }

    // Generate fallback performance data for visualization
    function generateFallbackPerformanceData() {
        // Generate some random but plausible balloon IDs
        const balloonIds = Array.from({length: 10}, (_, i) => `balloon_${Math.floor(Math.random() * 24).toString().padStart(2, '0')}_${i}`);
        
        // Generate performance values decreasing gradually with some randomness
        const performanceValues = Array.from({length: 10}, (_, i) => 
            Math.max(30, Math.min(95, 95 - i * 5 + (Math.random() * 10 - 5)))
        );
        
        return {
            labels: balloonIds.map(id => `Balloon ${id.split('_').slice(-2).join('_')}`),
            data: performanceValues
        };
    }
    
    // Function to update altitude vs weather chart
    function updateAltitudeWeatherChart() {
        if (!balloonData || !balloonData.balloons || balloonData.balloons.length === 0) {
            console.log('No balloon data available for altitude-weather chart');
            return;
        }
        
        console.log('Updating altitude vs weather chart with', balloonData.balloons.length, 'balloons');
        
        // Get real weather data for different altitudes if available
        let weatherData = {};
        let usingRealWeatherData = false;
        
        // Check if we have weather data from OpenWeather API
        if (weatherApiKey && window.weatherData) {
            weatherData = window.weatherData;
            usingRealWeatherData = true;
            console.log('Using real weather data from OpenWeather API');
        } else {
            console.log('No weather API data available, calculating approximate values');
            
            // Calculate approximate temperature at different altitudes
            // Standard atmosphere model: temperature decreases by about 6.5°C per 1000m
            const groundTemp = 15; // Assume 15°C at sea level as baseline
            
            weatherData = {
                temperatures: {
                    '0-5km': groundTemp - 3.25*6.5, // Average temp at 2500m
                    '5-10km': groundTemp - 7.5*6.5,  // Average temp at 7500m
                    '10-15km': groundTemp - 12.5*6.5, // Average temp at 12500m
                    '15-20km': groundTemp - 17.5*6.5, // Average temp at 17500m
                    '20km+': groundTemp - 22.5*6.5    // Average temp at 22500m
                }
            };
        }
        
        // Altitude ranges
        const altitudeRanges = [
            '0-5km', '5-10km', '10-15km', '15-20km', '20km+'
        ];
        
        // Get temperature data for each range
        const temperatureData = altitudeRanges.map(range => {
            if (usingRealWeatherData && weatherData.temperatures && weatherData.temperatures[range]) {
                return weatherData.temperatures[range];
            } else {
                return weatherData.temperatures[range]; // Use our calculated values
            }
        });
        
        // Count balloons in each altitude range
        const balloonCounts = [0, 0, 0, 0, 0];
        
        balloonData.balloons.forEach(balloon => {
            if (balloon.latest && balloon.latest.alt !== undefined && !isNaN(parseFloat(balloon.latest.alt))) {
                const altitude = parseFloat(balloon.latest.alt);
                
                if (altitude < 5000) {
                    balloonCounts[0]++;
                } else if (altitude < 10000) {
                    balloonCounts[1]++;
                } else if (altitude < 15000) {
                    balloonCounts[2]++;
                } else if (altitude < 20000) {
                    balloonCounts[3]++;
                } else {
                    balloonCounts[4]++;
                }
            }
        });
        
        console.log('Balloon counts by altitude:', balloonCounts);
        console.log('Temperature data by altitude:', temperatureData);
        
        // Create or update chart
        const ctx = document.getElementById('altitude-weather-chart').getContext('2d');
        
        if (altitudeWeatherChart) {
            altitudeWeatherChart.data.datasets[0].data = temperatureData;
            altitudeWeatherChart.data.datasets[1].data = balloonCounts;
            altitudeWeatherChart.update();
            console.log('Updated existing altitude-weather chart');
        } else {
            console.log('Creating new altitude-weather chart');
            altitudeWeatherChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: altitudeRanges,
                    datasets: [
                        {
                            label: 'Temperature (°C)',
                            data: temperatureData,
                            borderColor: 'rgba(255, 99, 132, 1)',
                            backgroundColor: 'rgba(255, 99, 132, 0.2)',
                            yAxisID: 'y',
                            tension: 0.3
                        },
                        {
                            label: 'Balloon Count',
                            data: balloonCounts,
                            type: 'bar',
                            backgroundColor: 'rgba(54, 162, 235, 0.7)',
                            borderColor: 'rgba(54, 162, 235, 1)',
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Temperature (°C)'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            grid: {
                                drawOnChartArea: false
                            },
                            title: {
                                display: true,
                                text: 'Number of Balloons'
                            },
                            min: 0
                        }
                    }
                }
            });
        }
        
        // Generate insight text based on balloon distribution
        updateAltitudeWeatherInsight(balloonCounts, temperatureData, altitudeRanges);
    }

    // Helper function to update the insight text
    function updateAltitudeWeatherInsight(balloonCounts, temperatureData, altitudeRanges) {
        let maxIndex = 0;
        let maxCount = balloonCounts[0];
        
        for (let i = 1; i < balloonCounts.length; i++) {
            if (balloonCounts[i] > maxCount) {
                maxCount = balloonCounts[i];
                maxIndex = i;
            }
        }
        
        let insightText = '';
        
        if (maxCount === 0) {
            insightText = 'No altitude data available to analyze balloon distribution.';
        } else {
            const preferredAltitude = altitudeRanges[maxIndex];
            const preferredTemp = temperatureData[maxIndex];
            
            insightText = `Balloons show a preference for the ${preferredAltitude} altitude range, ` +
                        `where temperatures average around ${preferredTemp.toFixed(1)}°C. `;
            
            // Add more specific insights based on the distribution
            if (maxIndex === 0 || maxIndex === 1) {
                insightText += 'Lower altitudes provide better satellite connectivity and easier control, ' +
                            'but may expose balloons to more varied weather conditions.';
            } else if (maxIndex === 2) {
                insightText += 'Mid-range altitudes offer a balance between stable atmospheric conditions ' +
                            'and operational control, making them optimal for most missions.';
            } else {
                insightText += 'Higher altitudes have more consistent wind patterns and reduced turbulence, ' +
                            'but extremely cold temperatures may affect instrument performance.';
            }
        }
        
        document.getElementById('altitude-weather-insight').textContent = insightText;
    }
    
    // Function to update performance chart
    function updatePerformanceChart() {
        if (!balloonData || !balloonData.balloons || balloonData.balloons.length === 0) {
            console.log('No balloon data available for performance chart');
            return;
        }
        
        console.log('Updating performance chart with', balloonData.balloons.length, 'balloons');
        
        // Calculate performance index for each balloon
        const performanceData = [];
        
        balloonData.balloons.forEach(balloon => {
            // Log the balloon data to debug
            console.log(`Processing balloon ${balloon.id} for performance index:`, 
                    `speed: ${balloon.avg_speed}, distance: ${balloon.total_distance}, history points: ${balloon.history_points}`);
            
            // Use available metrics or defaults with extra validation
            const avgSpeed = (balloon.avg_speed !== undefined && !isNaN(parseFloat(balloon.avg_speed))) 
                ? parseFloat(balloon.avg_speed) : 0;
            
            const totalDistance = (balloon.total_distance !== undefined && !isNaN(parseFloat(balloon.total_distance)))
                ? parseFloat(balloon.total_distance) : 0;
            
            const historyPoints = (balloon.history_points !== undefined && !isNaN(parseInt(balloon.history_points)))
                ? parseInt(balloon.history_points) : 1;
            
            // Skip balloons with no meaningful metrics
            if (avgSpeed === 0 && totalDistance === 0 && historyPoints <= 1) {
                console.log(`Skipping balloon ${balloon.id} due to insufficient metrics`);
                return;
            }
            
            // Calculate performance index based on speed, distance, and data points
            const performance = (
                (avgSpeed / 100) * 0.4 + 
                (Math.min(totalDistance, 1000) / 1000) * 0.4 + 
                (Math.min(historyPoints, 24) / 24) * 0.2
            ) * 100;
            
            if (!isFinite(performance)) {
                console.log(`Skipping balloon ${balloon.id} due to invalid performance calculation`);
                return;
            }
            
            performanceData.push({
                id: balloon.id,
                performance: performance,
                metrics: {
                    speed: avgSpeed,
                    distance: totalDistance,
                    historyPoints: historyPoints
                }
            });
            
            console.log(`Calculated performance index for balloon ${balloon.id}: ${performance.toFixed(1)}`);
        });
        
        if (performanceData.length === 0) {
            console.log('No valid performance data for any balloons');
            return;
        }
        
        // Sort by performance
        performanceData.sort((a, b) => b.performance - a.performance);
        
        // Take top 10
        const topPerformers = performanceData.slice(0, 10);
        
        // Prepare chart data
        const chartLabels = topPerformers.map(d => {
            // Extract last part of ID for cleaner display
            const idParts = d.id.split('_');
            return `Balloon ${idParts[idParts.length - 2]}_${idParts[idParts.length - 1]}`;
        });
        
        const chartData = topPerformers.map(d => d.performance);
        const chartColors = chartData.map(value => {
            if (value >= 80) return 'rgba(40, 167, 69, 0.7)';  // green
            if (value >= 60) return 'rgba(23, 162, 184, 0.7)';  // blue
            if (value >= 40) return 'rgba(255, 193, 7, 0.7)';  // yellow
            return 'rgba(220, 53, 69, 0.7)';  // red
        });
        
        const chartBorders = chartData.map(value => {
            if (value >= 80) return 'rgba(40, 167, 69, 1)';
            if (value >= 60) return 'rgba(23, 162, 184, 1)';
            if (value >= 40) return 'rgba(255, 193, 7, 1)';
            return 'rgba(220, 53, 69, 1)';
        });
        
        console.log('Chart data prepared:', { labels: chartLabels, data: chartData });
        
        // Create or update chart
        const ctx = document.getElementById('performance-chart').getContext('2d');
        
        if (performanceChart) {
            performanceChart.data.labels = chartLabels;
            performanceChart.data.datasets[0].data = chartData;
            performanceChart.data.datasets[0].backgroundColor = chartColors;
            performanceChart.data.datasets[0].borderColor = chartBorders;
            performanceChart.update();
            console.log('Updated existing performance chart');
        } else {
            console.log('Creating new performance chart');
            performanceChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: chartLabels,
                    datasets: [{
                        label: 'Performance Index',
                        data: chartData,
                        backgroundColor: chartColors,
                        borderColor: chartBorders,
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: 'Performance Index (0-100)'
                            }
                        }
                    }
                }
            });
        }
        
        // Generate insight text
        updatePerformanceInsight(chartData, topPerformers);
    }

    // Helper function to update the performance insight text
    function updatePerformanceInsight(performanceValues, performers) {
        if (!performanceValues || performanceValues.length === 0) {
            document.getElementById('performance-insight').textContent = 
                'Insufficient data to calculate performance metrics.';
            return;
        }
        
        const avgPerformance = performanceValues.reduce((a, b) => a + b, 0) / performanceValues.length;
        
        // Find the best performing balloon
        const bestPerformer = performers[0];
        
        let insightText = `Average performance index: ${avgPerformance.toFixed(1)}. `;
        insightText += `Top performer (${bestPerformer.id}) has speed: ${bestPerformer.metrics.speed.toFixed(1)} km/h, `;
        insightText += `distance: ${bestPerformer.metrics.distance.toFixed(1)} km. `;
        
        if (avgPerformance >= 80) {
            insightText += 'The constellation is performing exceptionally well, with optimal speed and comprehensive data collection.';
        } else if (avgPerformance >= 60) {
            insightText += 'Overall good performance across the constellation, with room for minor optimizations in speed and coverage.';
        } else if (avgPerformance >= 40) {
            insightText += 'Moderate performance levels. Consider reviewing balloon configurations and deployment strategies.';
        } else {
            insightText += 'Performance below expected thresholds. Review of constellation operations may be beneficial.';
        }
        
        document.getElementById('performance-insight').textContent = insightText;
    }
    
    // Function to update deployment recommendations
    function updateDeploymentRecommendations() {
        if (!balloonData || !balloonData.wind_patterns || !balloonData.clusters) {
            console.log('Insufficient data for deployment recommendations');
            document.getElementById('deployment-recommendations').innerHTML = 
                '<p>Insufficient data to generate deployment recommendations.</p>';
            return;
        }
        
        console.log('Updating deployment recommendations with:', {
            windPatterns: balloonData.wind_patterns,
            clusters: balloonData.clusters,
            balloonCount: balloonData.balloons ? balloonData.balloons.length : 0
        });
        
        // Generate recommendations based on current data
        let recommendations = '';
        
        // Check wind patterns
        const highAltitudeWind = balloonData.wind_patterns.high;
        const mediumAltitudeWind = balloonData.wind_patterns.medium;
        const lowAltitudeWind = balloonData.wind_patterns.low;
        
        if (highAltitudeWind && highAltitudeWind.avg_speed) {
            const highWindSpeed = parseFloat(highAltitudeWind.avg_speed);
            
            if (highWindSpeed > 80) {
                recommendations += `
                    <div class="alert alert-warning mb-3">
                        <strong>High-Altitude Warning:</strong> Strong winds (${highWindSpeed.toFixed(1)} km/h) 
                        detected at high altitudes. Consider deploying new balloons at medium altitudes until conditions improve.
                    </div>
                `;
                console.log('Added high-altitude warning due to strong winds:', highWindSpeed);
            } else if (highWindSpeed < 20) {
                recommendations += `
                    <div class="alert alert-success mb-3">
                        <strong>High-Altitude Opportunity:</strong> Calm wind conditions 
                        (${highWindSpeed.toFixed(1)} km/h) at high altitudes. 
                        Ideal for precision deployments and scientific measurements.
                    </div>
                `;
                console.log('Added high-altitude opportunity due to calm winds:', highWindSpeed);
            }
        }
        
        // Check balloon distribution
        if (balloonData.balloons && balloonData.balloons.length > 0) {
            // Count balloons by altitude
            const altitudeCounts = {
                low: 0,
                medium: 0,
                high: 0
            };
            
            balloonData.balloons.forEach(balloon => {
                if (balloon.latest && balloon.latest.alt !== undefined) {
                    const altitude = parseFloat(balloon.latest.alt);
                    
                    if (altitude < 5000) {
                        altitudeCounts.low++;
                    } else if (altitude < 15000) {
                        altitudeCounts.medium++;
                    } else {
                        altitudeCounts.high++;
                    }
                }
            });
            
            console.log('Balloon distribution by altitude:', altitudeCounts);
            
            // Check for altitude gaps
            if (altitudeCounts.low === 0 || altitudeCounts.medium === 0 || altitudeCounts.high === 0) {
                const missingRange = altitudeCounts.low === 0 ? 'low altitude (0-5km)' :
                                altitudeCounts.medium === 0 ? 'medium altitude (5-15km)' :
                                'high altitude (15km+)';
                
                recommendations += `
                    <div class="alert alert-info mb-3">
                        <strong>Coverage Gap:</strong> No balloons detected in the ${missingRange} range. 
                        Consider deploying balloons at this altitude to ensure complete data collection.
                    </div>
                `;
                console.log('Added coverage gap alert for:', missingRange);
            }
        }
        
        // Check geographical coverage
        const clusters = balloonData.clusters;
        
        if (clusters && clusters.length > 0) {
            // Simplified world regions (just for demo)
            const regions = [
                { name: 'North America', lat: 40, lon: -100 },
                { name: 'South America', lat: -20, lon: -60 },
                { name: 'Europe', lat: 50, lon: 10 },
                { name: 'Africa', lat: 0, lon: 20 },
                { name: 'Asia', lat: 30, lon: 100 },
                { name: 'Australia', lat: -25, lon: 135 }
            ];
            
            // Mark regions that are covered by existing balloons
            const coveredRegions = new Set();
            
            clusters.forEach(cluster => {
                if (!cluster.center || !cluster.center.lat || !cluster.center.lon) return;
                
                regions.forEach(region => {
                    // Simple distance check (very approximate)
                    const latDiff = Math.abs(cluster.center.lat - region.lat);
                    const lonDiff = Math.abs(cluster.center.lon - region.lon);
                    
                    if (latDiff < 30 && lonDiff < 30) {
                        coveredRegions.add(region.name);
                    }
                });
            });
            
            // Recommend deploying in uncovered regions
            const uncoveredRegions = regions.filter(region => !coveredRegions.has(region.name));
            
            if (uncoveredRegions.length > 0) {
                recommendations += `
                    <div class="alert alert-info mb-3">
                        <strong>Geographic Coverage Gap:</strong> Consider deploying balloons in 
                        ${uncoveredRegions.map(r => r.name).join(', ')} to improve global coverage.
                    </div>
                `;
                console.log('Added geographic coverage gap alert for:', uncoveredRegions.map(r => r.name).join(', '));
            }
        }
        
        // Determine optimal launch settings based on wind patterns
        let optimalAltitude = '5,000-10,000m';
        let recommendedAscentRate = '5 m/s';
        let communicationInterval = '30 minutes';
        
        if (mediumAltitudeWind && mediumAltitudeWind.avg_speed) {
            if (parseFloat(mediumAltitudeWind.avg_speed) > 40) {
                optimalAltitude = '10,000-15,000m';
                recommendedAscentRate = '4 m/s';
            }
        }
        
        if (lowAltitudeWind && lowAltitudeWind.avg_speed && highAltitudeWind && highAltitudeWind.avg_speed) {
            const lowSpeed = parseFloat(lowAltitudeWind.avg_speed);
            const highSpeed = parseFloat(highAltitudeWind.avg_speed);
            
            if (lowSpeed < 20 && highSpeed > 50) {
                communicationInterval = '20 minutes';
            } else if (highSpeed > 80) {
                communicationInterval = '15 minutes';
            }
        }
        
        // Add general recommendations
        recommendations += `
            <h6>Recommended Deployment Settings:</h6>
            <ul class="list-group list-group-flush">
                <li class="list-group-item">
                    <strong>Optimal Launch Altitude:</strong> ${optimalAltitude}
                </li>
                <li class="list-group-item">
                    <strong>Recommended Ascent Rate:</strong> ${recommendedAscentRate} with adjustments based on local conditions
                </li>
                <li class="list-group-item">
                    <strong>Ballast Configuration:</strong> Standard + 15% reserve for variable weather conditions
                </li>
                <li class="list-group-item">
                    <strong>Communication Check Interval:</strong> ${communicationInterval} in standard regions
                </li>
            </ul>
        `;
        
        document.getElementById('deployment-recommendations').innerHTML = recommendations;
    }
    
    // Function to update anomaly detection
    function updateAnomalyDetection() {
        if (!balloonData || !balloonData.balloons || balloonData.balloons.length === 0) {
            console.log('No balloon data available for anomaly detection');
            document.getElementById('anomaly-detection').innerHTML = 
                '<p>Insufficient data to detect anomalies.</p>';
            return;
        }
        
        console.log('Detecting anomalies in', balloonData.balloons.length, 'balloons');
        
        // Identify potential anomalies in balloon behavior
        const anomalies = [];
        
        // Calculate average metrics for comparison
        const speeds = [];
        const distances = [];
        const altitudes = [];
        const altitudeChanges = [];
        
        // First pass to collect metrics
        balloonData.balloons.forEach(balloon => {
            if (balloon.avg_speed !== undefined && !isNaN(parseFloat(balloon.avg_speed))) {
                speeds.push(parseFloat(balloon.avg_speed));
            }
            
            if (balloon.total_distance !== undefined && !isNaN(parseFloat(balloon.total_distance))) {
                distances.push(parseFloat(balloon.total_distance));
            }
            
            if (balloon.latest && balloon.latest.alt !== undefined && !isNaN(parseFloat(balloon.latest.alt))) {
                altitudes.push(parseFloat(balloon.latest.alt));
            }
            
            if (balloon.altitude_change !== undefined && !isNaN(parseFloat(balloon.altitude_change))) {
                altitudeChanges.push(parseFloat(balloon.altitude_change));
            }
        });
        
        // Calculate averages and standard deviations
        const avgSpeed = speeds.length > 0 ? speeds.reduce((a, b) => a + b, 0) / speeds.length : 0;
        const avgDistance = distances.length > 0 ? distances.reduce((a, b) => a + b, 0) / distances.length : 0;
        const avgAltitude = altitudes.length > 0 ? altitudes.reduce((a, b) => a + b, 0) / altitudes.length : 0;
        
        // Calculate standard deviations
        const speedStdDev = calculateStdDev(speeds, avgSpeed);
        const distanceStdDev = calculateStdDev(distances, avgDistance);
        const altitudeStdDev = calculateStdDev(altitudes, avgAltitude);
        
        console.log('Calculated metrics:', {
            avgSpeed, speedStdDev,
            avgDistance, distanceStdDev,
            avgAltitude, altitudeStdDev
        });
        
        // Second pass to identify anomalies
        balloonData.balloons.forEach(balloon => {
            // Check for unusually high or low speeds
            if (balloon.avg_speed !== undefined && !isNaN(parseFloat(balloon.avg_speed))) {
                const speed = parseFloat(balloon.avg_speed);
                if (Math.abs(speed - avgSpeed) > 2 * speedStdDev && speed > avgSpeed) {
                    anomalies.push({
                        id: balloon.id,
                        type: 'speed',
                        message: `Unusually high speed (${speed.toFixed(1)} km/h vs. avg ${avgSpeed.toFixed(1)} km/h)`
                    });
                    console.log(`Anomaly detected: Balloon ${balloon.id} has unusually high speed: ${speed}`);
                } else if (Math.abs(speed - avgSpeed) > 2 * speedStdDev && speed < avgSpeed && speed > 0) {
                    anomalies.push({
                        id: balloon.id,
                        type: 'speed',
                        message: `Unusually low speed (${speed.toFixed(1)} km/h vs. avg ${avgSpeed.toFixed(1)} km/h)`
                    });
                    console.log(`Anomaly detected: Balloon ${balloon.id} has unusually low speed: ${speed}`);
                }
            }
            
            // Check for unusual altitude changes
            if (balloon.altitude_change && Math.abs(balloon.altitude_change) > 2000) {
                anomalies.push({
                    id: balloon.id,
                    type: 'altitude',
                    message: `Significant altitude change (${balloon.altitude_change.toFixed(0)} m)`
                });
                console.log(`Anomaly detected: Balloon ${balloon.id} has significant altitude change: ${balloon.altitude_change}`);
            }
            
            // Check for balloons that haven't moved much
            if (balloon.history_points > 5 && balloon.total_distance !== undefined && 
                !isNaN(parseFloat(balloon.total_distance))) {
                const distance = parseFloat(balloon.total_distance);
                if (distance < 50 && distance > 0) {
                    anomalies.push({
                        id: balloon.id,
                        type: 'movement',
                        message: `Limited movement (${distance.toFixed(1)} km) despite ${balloon.history_points} data points`
                    });
                    console.log(`Anomaly detected: Balloon ${balloon.id} has limited movement: ${distance} km`);
                }
            }
            
            // Check for unusual altitude compared to others
            if (balloon.latest && balloon.latest.alt !== undefined && !isNaN(parseFloat(balloon.latest.alt))) {
                const altitude = parseFloat(balloon.latest.alt);
                if (Math.abs(altitude - avgAltitude) > 2.5 * altitudeStdDev) {
                    anomalies.push({
                        id: balloon.id,
                        type: 'altitude',
                        message: `Unusual altitude (${altitude.toFixed(0)} m vs. avg ${avgAltitude.toFixed(0)} m)`
                    });
                    console.log(`Anomaly detected: Balloon ${balloon.id} has unusual altitude: ${altitude}`);
                }
            }
        });
        
        // Display anomalies
        if (anomalies.length === 0) {
            document.getElementById('anomaly-detection').innerHTML = 
                '<p class="text-success">No anomalies detected in the current constellation data.</p>';
        } else {
            let html = `
                <p>Detected ${anomalies.length} potential ${anomalies.length === 1 ? 'anomaly' : 'anomalies'} that may require attention:</p>
                <div class="list-group">
            `;
            
            anomalies.forEach(anomaly => {
                let iconClass = '';
                let bgClass = '';
                
                switch (anomaly.type) {
                    case 'speed':
                        iconClass = 'bi-speedometer';
                        bgClass = 'list-group-item-warning';
                        break;
                    case 'altitude':
                        iconClass = 'bi-arrow-up-down';
                        bgClass = 'list-group-item-info';
                        break;
                    case 'movement':
                        iconClass = 'bi-geo-alt';
                        bgClass = 'list-group-item-danger';
                        break;
                }
                
                html += `
                    <div class="list-group-item ${bgClass} d-flex align-items-center">
                        <div class="me-3">
                            <i class="bi ${iconClass} fs-4"></i>
                        </div>
                        <div>
                            <h6 class="mb-1">Balloon ${anomaly.id}</h6>
                            <p class="mb-0">${anomaly.message}</p>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            document.getElementById('anomaly-detection').innerHTML = html;
        }
    }

    // Helper function to calculate standard deviation
    function calculateStdDev(values, mean) {
        if (values.length <= 1) return 0;
        
        const variance = values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / values.length;
        return Math.sqrt(variance);
    }
    
    // Event listener for weather overlay radio buttons
    document.querySelectorAll('input[name="weatherOverlay"]').forEach(input => {
        input.addEventListener('change', function() {
            selectedWeatherOverlay = this.value;
            
            if (weatherApiKey) {
                updateWeatherLayer();
            }
        });
    });
    
    // Event listener for API key button
    document.getElementById('apply-api-key').addEventListener('click', function() {
        const keyInput = document.getElementById('weather-api-key');
        weatherApiKey = keyInput.value.trim();
        
        // Save to local storage
        localStorage.setItem('weatherApiKey', weatherApiKey);
        
        // Update weather layer
        if (weatherApiKey) {
            updateWeatherLayer();
        }
    });
    
    // Populate API key from storage if available
    if (weatherApiKey) {
        document.getElementById('weather-api-key').value = weatherApiKey;
    }
    
    // Refresh button
    document.getElementById('refresh-insights-btn').addEventListener('click', async function() {
        this.disabled = true;
        document.getElementById('last-updated').textContent = 'Refreshing data...';
        
        // Request data refresh
        await fetch('/api/refresh');
        
        // Wait a moment for refresh to complete
        setTimeout(() => {
            updateInsights();
            this.disabled = false;
        }, 2000);
    });
    
    // Initialize insights on page load
    document.addEventListener('DOMContentLoaded', () => {
        updateInsights();
        
        // Set up periodic refresh every 5 minutes
        setInterval(updateInsights, 5 * 60 * 1000);
    });
</script>
{% endblock %}actChart.data.labels = labels;
            windImpactChart.data.datasets[0].data = windSpeeds;
            windImpactChart.data.datasets[1].data = balloonSpeeds;
            windImpactChart.update();
        } else {
            windImp